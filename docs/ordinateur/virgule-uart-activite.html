<!doctype html>
<html lang="fr">
    <head>
        <title>Activité : ajout d'une interface série</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../assets/normalize.css/normalize.css">
        <link rel="stylesheet" href="../assets/fontawesome/css/all.min.css">
        <link rel="stylesheet" href="../assets/katex/katex.min.css">
        <link rel="stylesheet" href="../styles/page.css">
    </head>
    <body>
        <header>
            
    <nav>
    
        <a href="virgule-simple-io-activite.html">&larr;&nbsp;Activité : mon premier système embarqué</a>
    
    
        <a href="virgule-interruptions-activite.html">Activité : gestion d'interruptions&nbsp;&rarr;</a>
    
</nav>

    
                <h1>Activité : ajout d'une interface série</h1>
                
                
            

        </header>
        
    
        <ul class="toc">
            
            
                
                <li><a href="#completer-le-projet-vivado">Compléter le projet Vivado</a></li>
            
                
                <li><a href="#contenu-des-nouveaux-fichiers-vhdl">Contenu des nouveaux fichiers VHDL</a></li>
            
                
                    <li><ul>
                    
                
                <li><a href="#controleur-dinterruptions">Contrôleur d’interruptions</a></li>
            
                
                <li><a href="#interface-serie-asynchrone">Interface série asynchrone</a></li>
            
                
                <li><a href="#programme-de-chargement-par-liaison-serie">Programme de chargement par liaison série</a></li>
            
                
                    </ul></li>
                    
                
                <li><a href="#modification-du-systeme">Modification du système</a></li>
            
                
                    <li><ul>
                    
                
                <li><a href="#paquetage-computerpkg">Paquetage Computer_pkg</a></li>
            
                
                <li><a href="#entite-computer">Entité Computer</a></li>
            
                
                <li><a href="#architecture-structural">Architecture Structural</a></li>
            
                
                    </ul></li>
                    
                
                <li><a href="#simuler-le-fonctionnement-du-systeme">Simuler le fonctionnement du système</a></li>
            
                
                <li><a href="#generer-le-bitstream-et-configurer-le-fpga">Générer le bitstream et configurer le FPGA</a></li>
            
                
                <li><a href="#utilisation-du-programme-de-chargement">Utilisation du programme de chargement</a></li>
            
                
                <li><a href="#programmation-en-langage-c">Programmation en langage C</a></li>
            
            
        </ul>
            
    
    <p>À présent, nous allons compléter notre ordinateur en lui ajoutant une interface
de communication série qui lui permettra d’échanger des données avec un autre
équipement, comme un PC par exemple.
Grâce à cette interface, l’entité <code>Computer</code> pourra&nbsp;:</p>
<ul>
<li>afficher du texte dans un terminal série sur votre PC,</li>
<li>recevoir des caractères frappés au clavier de votre PC,</li>
<li>recevoir des programmes à exécuter.</li>
</ul>
<section><h1 id="completer-le-projet-vivado" tabindex="-1">Compléter le projet Vivado</h1>
<p>Si ce n’est pas déjà fait, ouvrez votre projet <code>Computer</code> dans Vivado&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum
./scripts/vivado vivado/Computer/Computer.xpr
</code></pre>
<p class="icon-config">Dans le panneau, <em>Flow Navigator</em>, exécutez l’action <em>Add Sources</em>,
choisissez <em>Add or create design sources</em> et pressez le bouton <em>Next</em>.</p>
<p class="icon-config">Ajoutez les fichiers source VHDL suivants à votre projet.
Tous ces fichiers sont situés dans des sous-dossiers de <code>CoCiNum/src/vhdl</code>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Sous-dossier</th>
<th style="text-align:left">Fichier</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>UART</code></td>
<td style="text-align:left"><code>SerialReceiver.vhd</code></td>
<td style="text-align:left">Un récepteur série asynchrone.</td>
</tr>
<tr>
<td style="text-align:left"><code>UART</code></td>
<td style="text-align:left"><code>SerialTransmitter.vhd</code></td>
<td style="text-align:left">Un transmetteur série asynchrone.</td>
</tr>
<tr>
<td style="text-align:left"><code>UART</code></td>
<td style="text-align:left"><code>UART.vhd</code></td>
<td style="text-align:left">Une entité qui rassemble un récepteur et un transmetteur série.</td>
</tr>
<tr>
<td style="text-align:left"><code>Virgule</code></td>
<td style="text-align:left"><code>VInterruptController.vhd</code></td>
<td style="text-align:left">Un contrôleur d’interruptions pour le processeur <code>Virgule</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>Computer</code></td>
<td style="text-align:left"><code>Loader_pkg.vhd</code></td>
<td style="text-align:left">Un programme de démarrage pour l’entité <code>Computer</code>.</td>
</tr>
</tbody>
</table>
<p class="icon-config">Dans le panneau, <em>Flow Navigator</em>, exécutez à nouveau l’action <em>Add Sources</em>,
choisissez <em>Add or create constraints</em> et pressez le bouton <em>Next</em>.</p>
<p class="icon-config">Ajoutez le fichier de contraintes suivant à votre projet&nbsp;:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Sous-dossier</th>
<th style="text-align:left">Fichier</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Basys3</code></td>
<td style="text-align:left"><code>Basys3_UART.xdc</code></td>
<td style="text-align:left">Fichier de contraintes pour Vivado, brochage de l’interface série.</td>
</tr>
</tbody>
</table>
</section><section><h1 id="contenu-des-nouveaux-fichiers-vhdl" tabindex="-1">Contenu des nouveaux fichiers VHDL</h1>
</section><section><h2 id="controleur-dinterruptions" tabindex="-1">Contrôleur d’interruptions</h2>
<p>L’entité <code>VInterruptController</code> peut gérer les événements ou les demandes
d’interruption de 32 sources connectées à chaque bit de son entrée <code>events_i</code>.
Lorsqu’elles sont autorisées, il transmet les demandes d’interruption au
processeur sur <code>irq_o</code>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Port</th>
<th style="text-align:left">Direction</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>clk_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Le signal d’horloge global</td>
</tr>
<tr>
<td style="text-align:left"><code>reset_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">La commande de réinitialisation</td>
</tr>
<tr>
<td style="text-align:left"><code>valid_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Demande de transfert de donnée</td>
</tr>
<tr>
<td style="text-align:left"><code>ready_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Indicateur de fin d’une lecture ou d’une écriture</td>
</tr>
<tr>
<td style="text-align:left"><code>address_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Le bus d’adresses</td>
</tr>
<tr>
<td style="text-align:left"><code>write_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Vecteur de 4 bits</td>
<td style="text-align:left">Sélection des octets à écrire</td>
</tr>
<tr>
<td style="text-align:left"><code>wdata_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Vecteur de 32 bits</td>
<td style="text-align:left">Le bus de données en écriture</td>
</tr>
<tr>
<td style="text-align:left"><code>rdata_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Vecteur de 32 bits</td>
<td style="text-align:left">Le bus de données en lecture</td>
</tr>
<tr>
<td style="text-align:left"><code>events_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Vecteur de 32 bits</td>
<td style="text-align:left">Indicateurs d’événements ou de demandes d’interruptions de chaque périphérique</td>
</tr>
<tr>
<td style="text-align:left"><code>irq_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Demande d’interruption (interrupt request)</td>
</tr>
</tbody>
</table>
<p><code>VInterruptController</code> est aussi un périphérique que le processeur peut
configurer et interroger.
Son entrée <code>address_i</code> est sur un bit car il n’y a que deux registres&nbsp;:</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>address_i</code></th>
<th style="text-align:left">Registre</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>'0'</code></td>
<td style="text-align:left"><code>mask_reg</code></td>
<td style="text-align:left">Masque de 32 bits qui indiquent quelles sources d’interruptions sont autorisées.</td>
</tr>
<tr>
<td style="text-align:center"><code>'1'</code></td>
<td style="text-align:left"><code>events_reg</code></td>
<td style="text-align:left">Indicateurs de chaque événement en attente de traitement.</td>
</tr>
</tbody>
</table>
<p>Typiquement, dans un programme qui gère des interruptions, on
configurera <code>mask_reg</code> pour choisir à quels événements on souhaite réagir.
À chaque fois qu’une interruption sera demandée&nbsp;:</p>
<ol>
<li>On lira <code>events_reg</code> pour identifier le type d’événement à traiter.</li>
<li>On écrira un <code>'1'</code> dans le bit du registre <code>events_reg</code> correspondant à cet
évenement pour indiquer que celui-ci a été traité.</li>
</ol>
</section><section><h2 id="interface-serie-asynchrone" tabindex="-1">Interface série asynchrone</h2>
<p>Les entités <code>SerialTransmitter</code> et <code>SerialReceiver</code> seront utilisées
pour réaliser une interface de communication série communément appelée
UART (<em>Universal Asynchronous Receiver Transmitter</em>).
Cette interface permettra au processeur de communiquer avec votre PC à
travers une interface série/USB.</p>
<p>Dans le fichier <code>UART/UART.vhd</code> nous fournissons un composant <code>UART</code>
composé d’un transmetteur et d’un récepteur.
Il possède les paramètres génériques suivants afin
de régler ses diviseurs de fréquence internes&nbsp;:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Paramètre</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>CLK_FREQUENCY_HZ</code></td>
<td style="text-align:left">Entier</td>
<td style="text-align:left">La fréquence de l’horloge <code>clk_i</code>, en Hz</td>
</tr>
<tr>
<td style="text-align:left"><code>BIT_RATE_HZ</code></td>
<td style="text-align:left">Entier</td>
<td style="text-align:left">La vitesse de communication série, en bits par seconde</td>
</tr>
</tbody>
</table>
<p>Et voici la liste de ses ports&nbsp;:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Port</th>
<th style="text-align:left">Direction</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>clk_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Le signal d’horloge global</td>
</tr>
<tr>
<td style="text-align:left"><code>reset_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">La commande de réinitialisation</td>
</tr>
<tr>
<td style="text-align:left"><code>valid_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Demande de transfert de donnée</td>
</tr>
<tr>
<td style="text-align:left"><code>ready_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Indicateur de fin d’une lecture ou d’une écriture</td>
</tr>
<tr>
<td style="text-align:left"><code>write_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">La commande d’écriture</td>
</tr>
<tr>
<td style="text-align:left"><code>wdata_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Vecteur de 8 bits</td>
<td style="text-align:left">Le bus de données en écriture (octet à envoyer)</td>
</tr>
<tr>
<td style="text-align:left"><code>rdata_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Vecteur de 8 bits</td>
<td style="text-align:left">Le bus de données en lecture (octet reçu)</td>
</tr>
<tr>
<td style="text-align:left"><code>tx_evt_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Indicateur de fin de transmission</td>
</tr>
<tr>
<td style="text-align:left"><code>rx_evt_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Indicateur de fin de réception</td>
</tr>
<tr>
<td style="text-align:left"><code>tx_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">La ligne de transmission série</td>
</tr>
<tr>
<td style="text-align:left"><code>rx_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">La ligne de réception série</td>
</tr>
</tbody>
</table>
</section><section><h2 id="programme-de-chargement-par-liaison-serie" tabindex="-1">Programme de chargement par liaison série</h2>
<p>Le fichier <code>Loader_pkg.vhd</code> contient un programme de démarrage et de chargement.
Son rôle est de recevoir un autre programme par la liaison série,
de le charger en mémoire et de l’exécuter.</p>
<p>Cela évitera de resynthétiser l’entité <code>Computer</code> à chaque fois que vous voudrez
exécuter un nouveau programme.</p>
</section><section><h1 id="modification-du-systeme" tabindex="-1">Modification du système</h1>
</section><section><h2 id="paquetage-computerpkg" tabindex="-1">Paquetage <code>Computer_pkg</code></h2>
<p>Dans le fichier <code>Computer_pkg.vhd</code>, modifiez la constante <code>MEM_CONTENT</code>
pour que le programme initial chargé en mémoire soit celui défini dans le
paquetage <code>Loader_pkg</code>&nbsp;:</p>
<pre><code class="icon-file language-vhdl"><span class="hljs-keyword">constant</span> MEM_CONTENT : word_vector_t := work.Loader_pkg.DATA;
</code></pre>
<p class="icon-file">Ajoutez des constantes pour définir les caractéristiques des nouveaux
périphériques du système&nbsp;:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Constante</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Valeur</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>INTC_ADDRESS</code></td>
<td style="text-align:left">Octet</td>
<td style="text-align:left">81<sub>hex</sub></td>
<td style="text-align:left">Les bits 31 à 24 de l’adresse pour accéder au contrôleur d’interruption.</td>
</tr>
<tr>
<td style="text-align:left"><code>UART_ADDRESS</code></td>
<td style="text-align:left">Octet</td>
<td style="text-align:left">82<sub>hex</sub></td>
<td style="text-align:left">Les bits 31 à 24 de l’adresse pour accéder à l’interface série.</td>
</tr>
<tr>
<td style="text-align:left"><code>UART_BIT_RATE_HZ</code></td>
<td style="text-align:left">Entier</td>
<td style="text-align:left">115200</td>
<td style="text-align:left">La vitesse de communication de l’interface série, en bits/seconde.</td>
</tr>
<tr>
<td style="text-align:left"><code>INTC_EVENTS_UART_RX</code></td>
<td style="text-align:left">Entier</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Pour le contrôleur d’interruptions, le numéro de l’événement indiquant la réception d’un octet sur l’interface série.</td>
</tr>
<tr>
<td style="text-align:left"><code>INTC_EVENTS_UART_TX</code></td>
<td style="text-align:left">Entier</td>
<td style="text-align:left">1</td>
<td style="text-align:left">Pour le contrôleur d’interruptions, le numéro de l’événement indiquant la fin de l’envoi d’un octet sur l’interface série.</td>
</tr>
</tbody>
</table>
</section><section><h2 id="entite-computer" tabindex="-1">Entité <code>Computer</code></h2>
<p class="icon-file">Dans le fichier <code>Computer.vhd</code>, modifiez l’entité <code>Computer</code> en ajoutant les
ports suivants&nbsp;:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Port</th>
<th style="text-align:left">Direction</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>uart_rx_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">La ligne de réception série</td>
</tr>
<tr>
<td style="text-align:left"><code>uart_tx_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">La ligne de transmission série</td>
</tr>
</tbody>
</table>
</section><section><h2 id="architecture-structural" tabindex="-1">Architecture <code>Structural</code></h2>
<p class="icon-file">Dans le fichier <code>Computer.vhd</code>, dans l’architecture <code>Structural</code>,
modifiez l’instance <code>sync_inst</code> pour lui ajouter une entrée et une sortie
supplémentaires que vous connecterez de la manière indiquée ci-dessous.
Ensuite, instanciez les entités <code>UART</code> et <code>VInterruptController</code>
représentées sur ce schéma.
Pensez à déclarer les signaux manquants.</p>
<p><a href="Computer-Loader-architecture.svg"><img src="Computer-Loader-architecture.svg" alt="Ajout d'une interface série"></a></p>
<p>Le rectangle rose en pointillés, au centre du schéma, représente toutes les
instructions d’affectation concurrentes qui gèrent la communication entre le
processeur et ses périphériques.</p>
<p class="icon-file">Complétez l’architecture pour que le processeur puisse communiquer avec
l’UART et le contrôleur d’interruptions.</p>
<ul>
<li>Quelles instructions devez-vous modifier&nbsp;?</li>
<li>Quelles instructions devez-vous ajouter&nbsp;?</li>
</ul>
<p class="icon-question">Représentez sous forme de tableau le nouveau plan d’adressage du système
en incluant&nbsp;:</p>
<ul>
<li>les registres <code>mask_reg</code> et <code>events_reg</code> du contrôleur d’interruptions,</li>
<li>les données de l’UART.</li>
</ul>
<p class="icon-check">Faites valider votre plan d’adressage par l’enseignant de votre groupe.</p>
</section><section><h1 id="simuler-le-fonctionnement-du-systeme" tabindex="-1">Simuler le fonctionnement du système</h1>
<p>Pour un premier test du système en simulation, nous allons utiliser
un programme simple qui réalise un écho, c’est-à-dire qu’il retransmet
chaque octet qu’il reçoit sur la liaison série.
Le programme se trouve dans le dossier <code>CoCiNum/src/asm/Echo</code>.</p>
<!-- TODO Améliorer ce programme pour qu'il supporte la réception pendant un envoi -->
<pre><code class="icon-file language-riscvasm">    .set INTC_ADDRESS,        <span class="hljs-number">0x81000000</span>
    .set UART_ADDRESS,        <span class="hljs-number">0x82000000</span>
    .set INTC_EVENTS_UART_RX, <span class="hljs-number">0x00000001</span>
    .set INTC_EVENTS_UART_TX, <span class="hljs-number">0x00000002</span>

    .<span class="hljs-meta">global</span> main
<span class="hljs-symbol">main</span>:
    <span class="hljs-keyword">li </span><span class="hljs-built_in">x5</span>, INTC_ADDRESS
    <span class="hljs-keyword">li </span><span class="hljs-built_in">x6</span>, UART_ADDRESS
<span class="hljs-symbol">
main_rx_loop:</span>
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">x7</span>, <span class="hljs-number">4</span>(<span class="hljs-built_in">x5</span>)                     <span class="hljs-comment">/* Lire le registre events_reg du contrôleur d'interruptions.        */</span>
    <span class="hljs-keyword">andi </span><span class="hljs-built_in">x7</span>, <span class="hljs-built_in">x7</span>, INTC_EVENTS_UART_RX <span class="hljs-comment">/* Isoler le bit indicateur de l'événement "réception" de l'UART.    */</span>
    <span class="hljs-keyword">beqz </span><span class="hljs-built_in">x7</span>, main_rx_loop            <span class="hljs-comment">/* S'il est égal à zéro, continuer la boucle d'attente.              */</span>
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">x7</span>, <span class="hljs-number">4</span>(<span class="hljs-built_in">x5</span>)                     <span class="hljs-comment">/* Sinon, remettre à zéro l'indicateur d'événement.                  */</span>

    <span class="hljs-keyword">lbu </span><span class="hljs-built_in">x8</span>, (<span class="hljs-built_in">x6</span>)                     <span class="hljs-comment">/* Lire l'octet de donnée reçu sur l'entrée série.                   */</span>
    <span class="hljs-keyword">sb </span> <span class="hljs-built_in">x8</span>, (<span class="hljs-built_in">x6</span>)                     <span class="hljs-comment">/* Envoyer le même octet sur la sortie série.                        */</span>
<span class="hljs-symbol">
main_tx_loop:</span>
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">x7</span>, <span class="hljs-number">4</span>(<span class="hljs-built_in">x5</span>)                     <span class="hljs-comment">/* Lire le registre events_reg du contrôleur d'interruptions.        */</span>
    <span class="hljs-keyword">andi </span><span class="hljs-built_in">x7</span>, <span class="hljs-built_in">x7</span>, INTC_EVENTS_UART_TX <span class="hljs-comment">/* Isoler le bit indicateur de l'événement "transmission" de l'UART. */</span>
    <span class="hljs-keyword">beqz </span><span class="hljs-built_in">x7</span>, main_tx_loop            <span class="hljs-comment">/* S'il est égal à zéro, continuer la boucle d'attente.              */</span>
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">x7</span>, <span class="hljs-number">4</span>(<span class="hljs-built_in">x5</span>)                     <span class="hljs-comment">/* Sinon, remettre à zéro l'indicateur d'événement.                  */</span>

    <span class="hljs-keyword">j </span>main_rx_loop                   <span class="hljs-comment">/* Retourner à la boucle d'attente de réception.                     */</span>
</code></pre>
<p>Les blocs d’instructions désignés par les étiquettes <code>main_rx_loop</code> et <code>main_tx_loop</code>
réalisent des boucles d’attente dans lesquelles le programme interroge de façon
répétitive le registre <code>events_reg</code> du contrôleur d’interruptions
(à l’adresse 81000004<sub>hex</sub>).
Des opérations de masquage (<code>andi</code>) isolent le bit indicateur d’un événement
en émission ou en réception.
Les boucles d’attente s’exécutent tant que le bit testé est nul (<code>beqz</code>).</p>
<p>Lorsqu’un événement a été détecté, une instruction <code>sw</code> commande la remise à
zéro de l’indicateur correspondant dans le registre <code>events_reg</code>.</p>
<p>L’instruction <code>lbu</code> est utilisée pour lire l’octet reçu.
L’instruction <code>sb</code> écrit cet octet vers l’UART pour qu’il soit transmis.</p>
<div class="info">
<p>Ce programme n’utilise pas d’interruptions.
La détection des événements s’effectue avec des boucles d’attente
selon le principe de <em>l’attente active</em> (également appelée
<em>scrutation</em>, ou en anglais, <em>polling</em>).</p>
<p>Nous utiliserons les interruptions au cours de l’activité suivante.</p>
</div>
<p>Compilez le programme <code>Echo.s</code> pour produire un paquetage VHDL <code>Echo_pkg</code>&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum/src/asm/Echo
make
</code></pre>
<div class="info">
<p>La simulation s’appuie sur une version alternative du paquetage <code>Computer_pkg</code>
située dans le sous-dossier <code>Computer/tests-uart</code>.
Vous ne devez pas modifier pas votre fichier <code>Computer_pkg.vhd</code>&nbsp;!</p>
<p>En simulation, nous utiliserons directement le programme <code>Echo</code>&nbsp;:</p>
<pre><code class="language-vhdl"><span class="hljs-keyword">constant</span> MEM_CONTENT : word_vector_t := work.Echo_pkg.DATA;
</code></pre>
<p>Pour éviter de surcharger votre PC, les fréquences d’horloge et de
communication seront plus petites que sur le vrai matériel&nbsp;:</p>
<pre><code class="language-vhdl"><span class="hljs-keyword">constant</span> CLK_FREQUENCY_HZ : <span class="hljs-built_in">positive</span> := <span class="hljs-number">10e3</span>;
<span class="hljs-keyword">constant</span> UART_BIT_RATE_HZ : <span class="hljs-built_in">positive</span> := <span class="hljs-number">1e3</span>;
</code></pre>
</div>
<p>Démarrez la simulation en exécutant les commandes suivantes&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum/src/vhdl/Computer/tests-uart
make
</code></pre>
<p class="icon-check">Si tout s’est bien passé, la fenêtre ci-dessous doit s’afficher.
Dans le cas contraire, vérifiez les messages d’erreurs, corrigez votre fichier
<code>Computer.vhd</code> et relancez la commande <code>make</code>.</p>
<p><img src="../assets/images/ordinateur/Computer-cocotb-uart.png" alt="Simulation de l'entité Computer avec UART"></p>
<p class="icon-keyboard">Entrez des caractères dans le champ de texte <em>Input</em>. Ces caractères sont envoyés
à votre entité <code>Computer</code> par son entrée série.</p>
<p class="icon-check">Vérifiez que le programme <code>Echo</code> s’exécute correctement.
Les caractères reçus doivent être renvoyés par <code>Computer</code> sur sa sortie série
et doivent s’afficher dans le champ <em>Output</em>.</p>
<div class="warning">
<p>Le programme de test enregistre tous les signaux du système dans un fichier.
Ne laissez pas la fenêtre ouverte trop longtemps pour éviter de saturer
votre espace de stockage.</p>
</div>
<p>Après avoir fermé la fenêtre <em>tk</em>, affichez les chronogrammes à l’aide de la commande suivante&nbsp;:</p>
<pre><code class="icon-term language-bash">gtkwave -S Computer.tcl Computer.ghw
</code></pre>
<p class="icon-mouse">Réglez le niveau de zoom et faites défiler les chronogrammes de manière à
observer les changements des signaux <code>uart_rx_i</code>, <code>uart_tx_o</code>, <code>uart_rx_evt</code> et <code>uart_tx_evt</code>.</p>
<p class="icon-question">En faisant le lien avec le programme <code>Echo.s</code>, expliquez ce que vous obtenez.</p>
</section><section><h1 id="generer-le-bitstream-et-configurer-le-fpga" tabindex="-1">Générer le bitstream et configurer le FPGA</h1>
<p class="icon-mouse">Dans Vivado, générez le fichier binaire à charger dans le FPGA&nbsp;:
<em>Flow Navigator</em> → <em>Program and Debug</em> → <em>Generate Bitstream</em>.</p>
<p class="icon-hand">Si ce n’est pas déjà fait, reliez le connecteur micro-USB de la carte à un port
USB de votre PC et mettez la carte sous tension.</p>
<p class="icon-mouse">Connectez Vivado à votre carte Basys3&nbsp;: <em>Flow Navigator</em> → <em>Program and Debug</em> → <em>Open Hardware Manager</em> → <em>Open Target</em> → <em>Auto-connect</em>.</p>
<p class="icon-mouse">Configurez le FPGA&nbsp;: <em>Flow Navigator</em> → <em>Program and Debug</em> → <em>Open Hardware Manager</em> → <em>Program Device</em>.</p>
</section><section><h1 id="utilisation-du-programme-de-chargement" tabindex="-1">Utilisation du programme de chargement</h1>
<p>Nous allons utiliser le logiciel <em>GTKTerm</em> pour communiquer avec
l’ordinateur embarqué dans notre FPGA par liaison série sur USB&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum
./scripts/gtkterm
</code></pre>
<p class="icon-mouse">Dans le menu <em>Configuration</em> de GTKTerm, activez l’option <em>CR LF auto</em>.</p>
<div class="info">
<p>GTKTerm est déjà configuré pour utiliser le port série <code>/dev/ttyUSB1</code>
avec 8 bits de données, 1 bit d’arrêt, pas de contrôle de parité.</p>
</div>
<p class="icon-hand">Forcez un redémarrage du processeur en pressant le bouton-poussoir central
de la carte Basys3.</p>
<p>La fenêtre GTKTerm doit à présent afficher le texte&nbsp;:</p>
<pre><code>\\// This is the Virgule program loader.
\\// Send an hex file to execute or press ESC to switch into interactive mode.
</code></pre>
<p>Pour continuer, nous devons donc envoyer un programme au format
<a href="https://fr.wikipedia.org/wiki/HEX_(Intel)">Intel HEX</a> par liaison série vers le FPGA.</p>
<p>Nous allons reprendre le programme <code>Echo.s</code>, mais au lieu de le convertir
en VHDL, nous allons produire un fichier <code>Echo.hex</code>.
Exécutez les commandes suivantes dans un terminal&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum/src/asm/Echo
make Echo.hex
<span class="hljs-built_in">cat</span> Echo.hex
</code></pre>
<p>Le contenu du fichier <code>Echo.hex</code> doit ressembler à ceci&nbsp;:</p>
<pre><code>:100000006F0040016F00C0004800000000000000C9
:1000100073002030970100009381810717010100D0
:10002000130141FE9302C0081303C00863F8620085
:1000300023A0020093824200E3EC62FEEF00C001C5
:100040009702000083A282FC67800200000000008B
:100050000000000000000000B702008137030082AA
:1000600083A3420093F31300E38C03FE23A27200E8
:10007000034403002300830083A3420093F323007F
:0C008000E38C03FE23A272006FF09FFDD2
:00000001FF
</code></pre>
<p>Envoyez-le au FPGA par la liaison série&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cat</span> Echo.hex &gt; /dev/ttyUSB1
</code></pre>
<p class="icon-check">GTKTerm doit afficher&nbsp;:</p>
<pre><code>\\// Starting user program.
</code></pre>
<!-- TODO Utiliser plutôt la commande echo pour envoyer une chaîne -->
<p class="icon-check">Dans la fenêtre de GTKTerm, entrez des caractères au clavier.
Chaque caractère que vous avez entré doit s’afficher en écho.</p>
<div class="warning">
<p>Le programme <code>Echo</code> tourne en boucle et ne se termine jamais.
Pour réinitialiser le système, vous devez recharger le bitstream dans le FPGA.</p>
<p class="icon-mouse">Dans Vivado&nbsp;: <em>Flow Navigator</em> → <em>Program and Debug</em> → <em>Open Hardware Manager</em> → <em>Program Device</em>.</p>
<p>Par la suite, nous ferons attention à écrire des programmes qui se terminent.</p>
</div>
</section><section><h1 id="programmation-en-langage-c" tabindex="-1">Programmation en langage C</h1>
<p>Nous vous proposons une réécriture du programme <code>Echo</code> en langage C.
Créez et éditez un nouveau fichier <code>Echo.c</code>&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum/src/c
<span class="hljs-built_in">mkdir</span> Echo
<span class="hljs-built_in">cd</span> Echo
gedit Echo.c &amp;
</code></pre>
<pre><code class="icon-file language-c"><span class="hljs-comment">// Echo.c</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span>

<span class="hljs-comment">// Définition des adresses des périphériques.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_ADDR 0x81000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_ADDR 0x82000000</span>

<span class="hljs-comment">// Définition des registres des périphériques.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_MASK_REG   INTC_ADDR</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_EVENTS_REG (INTC_ADDR + 4)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_DATA_REG   UART_ADDR</span>

<span class="hljs-comment">// Définition des masques pour détecter et acquitter les événements.</span>
<span class="hljs-comment">// masque = 2^(numéro de l'interruption)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_EVENTS_UART_RX 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_EVENTS_UART_TX 2</span>

<span class="hljs-comment">/* -------------------------------------------------------------------------- *
 * Fonctions d'accès aux registres des périphériques.
 * -------------------------------------------------------------------------- */</span>

<span class="hljs-comment">// Lire un octet à l'adresse addr (équivaut à l'instruction LBU).</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">read8</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span> {
    <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>*)addr;
}

<span class="hljs-comment">// Écrire l'octet val à l'adresse addr (équivaut à l'instruction SB).</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">write8</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span> val)</span> {
    *(<span class="hljs-type">uint8_t</span>*)addr = val;
}

<span class="hljs-comment">// Lire un mot de 32 bits à l'adresse addr (équivaut à l'instruction LW).</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">read32</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span> {
    <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>*)addr;
}

<span class="hljs-comment">// Écrire le mot de 32 bits val à l'adresse addr (équivaut à l'instruction SW).</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">write32</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint32_t</span> val)</span> {
    *(<span class="hljs-type">uint32_t</span>*)addr = val;
}

<span class="hljs-comment">/* -------------------------------------------------------------------------- *
 * Fonctions de lecture/écriture sur l'interface série.
 * -------------------------------------------------------------------------- */</span>

<span class="hljs-comment">// Envoyer un caractère à travers la liaison série.</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">UART_send_char</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> {
    <span class="hljs-comment">// Ecrire le caractère dans le registre de données.</span>
    write8(UART_DATA_REG, c);
    <span class="hljs-comment">// Attendre que l'envoi soit terminé.</span>
    <span class="hljs-keyword">while</span> (!(read32(INTC_EVENTS_REG) &amp; INTC_EVENTS_UART_TX));
    <span class="hljs-comment">// Signaler que l'événement a été traité.</span>
    write32(INTC_EVENTS_REG, INTC_EVENTS_UART_TX);
}

<span class="hljs-comment">// Envoyer une chaîne de caractères à travers la liaison série.</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">UART_send_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span> {
    <span class="hljs-comment">// Tant que le caractère courant est non nul.</span>
    <span class="hljs-keyword">while</span> (*str) {
        <span class="hljs-comment">// Envoyer le caractère courant.</span>
        UART_send_char(*str);
        <span class="hljs-comment">// Passer au caractère suivant.</span>
        str ++;
    }
}

<span class="hljs-comment">// Recevoir un caractère en provenance de la liaison série.</span>
<span class="hljs-type">char</span> <span class="hljs-title function_">UART_receive_char</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-comment">// Attendre la réception.</span>
    <span class="hljs-keyword">while</span> (!(read32(INTC_EVENTS_REG) &amp; INTC_EVENTS_UART_RX));
    <span class="hljs-comment">// Signaler que l'événement a été traité.</span>
    write32(INTC_EVENTS_REG, INTC_EVENTS_UART_RX);
    <span class="hljs-comment">// Retourner le caractère reçu.</span>
    <span class="hljs-keyword">return</span> read8(UART_DATA_REG);
}

<span class="hljs-comment">/* -------------------------------------------------------------------------- *
 * Programme principal.
 * -------------------------------------------------------------------------- */</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-comment">// Envoyer un message d'accueil.</span>
    UART_send_string(<span class="hljs-string">"Echo&gt; "</span>);
    <span class="hljs-comment">// Afficher chaque caractère reçu jusqu'à ce que l'utilisateur presse &lt;Entrée&gt;</span>
    <span class="hljs-type">char</span> c;
    <span class="hljs-keyword">do</span> {
    	c = UART_receive_char();
    	UART_send_char(c);
    } <span class="hljs-keyword">while</span> (c != <span class="hljs-string">'\r'</span>);
    <span class="hljs-comment">// Envoyer un message de fin.</span>
    UART_send_string(<span class="hljs-string">"\nBye!\n"</span>);
}
</code></pre>
<p>Compilez ce programme&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum/src/c/Echo
riscv64-unknown-elf-gcc -march=rv32i -mabi=ilp32 -ffreestanding -nostdlib -T ../../../scripts/Virgule.ld -o Echo.elf ../../asm/Startup/Startup.s Echo.c
riscv64-unknown-elf-objcopy -O ihex Echo.elf Echo.hex
</code></pre>
<p>Les éléments des deux dernières lignes de commande sont&nbsp;:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Commande ou argument</th>
<th style="text-align:left">Signification</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>riscv64-unknown-elf-gcc</code></td>
<td style="text-align:left">Invoquer le compilateur GCC pour RISC-V</td>
</tr>
<tr>
<td style="text-align:left"><code>-march=rv32i</code></td>
<td style="text-align:left">Utiliser le jeu d’instructions de base RV32I de l’architecture RISC-V</td>
</tr>
<tr>
<td style="text-align:left"><code>-mabi=ilp32</code></td>
<td style="text-align:left">Utiliser les conventions d’appel de sous-programmes pour RISC-V 32 bits</td>
</tr>
<tr>
<td style="text-align:left"><code>-ffreestanding</code></td>
<td style="text-align:left">Le programme à compiler n’utilise aucune fonction prédéfinie</td>
</tr>
<tr>
<td style="text-align:left"><code>-nostdlib</code></td>
<td style="text-align:left">Le programme à compiler n’utilise pas la bibliothèque standard C</td>
</tr>
<tr>
<td style="text-align:left"><code>-T ../../../scripts/Virgule.ld</code></td>
<td style="text-align:left">Utiliser le fichier de définition du plan mémoire <code>Virgule.ld</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-o Echo.elf</code></td>
<td style="text-align:left">Le programme exécutable s’appellera <code>Echo.elf</code></td>
</tr>
<tr>
<td style="text-align:left"><code>../../asm/Startup/Startup.s</code></td>
<td style="text-align:left">Assembler le programme de démarrage <code>Startup.s</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Echo.c</code></td>
<td style="text-align:left">Compiler le programme <code>Echo.c</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Commande ou argument</th>
<th style="text-align:left">Signification</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>riscv64-unknown-elf-objcopy</code></td>
<td style="text-align:left">Invoquer l’outil de conversion de formats de programmes</td>
</tr>
<tr>
<td style="text-align:left"><code>-O ihex</code></td>
<td style="text-align:left">Créer un fichier au format <a href="https://fr.wikipedia.org/wiki/HEX_(Intel)">Intel HEX</a></td>
</tr>
<tr>
<td style="text-align:left"><code>Echo.elf</code></td>
<td style="text-align:left">Convertir le fichier <code>Echo.elf</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Echo.hex</code></td>
<td style="text-align:left">Écrire le résultat dans le fichier <code>Echo.hex</code></td>
</tr>
</tbody>
</table>
<p>Dans la même fenêtre terminal exécutez la commande&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cat</span> Echo.hex &gt; /dev/ttyUSB1
</code></pre>
<!-- Dans GTKTerm, dans le menu *File*, choisissez *Send Raw File*
et sélectionnez le fichier `CoCiNum/src/c/Echo/Echo.hex`. -->
<p class="icon-check">Dans la fenêtre GTKTerm, vous devez à présent voir&nbsp;:</p>
<pre><code>\\// Starting user program.
Echo&gt;
</code></pre>
<p>Tapez quelques caractères au clavier. Ils doivent s’afficher à
la suite de la ligne <em>Echo &gt;</em>&nbsp;:</p>
<pre><code class="icon-keyboard">\\// Starting user program...
Echo&gt; Je viens de taper ceci
</code></pre>
<p>Pressez la touche <em>Entrée</em>. Le programme doit se terminer en affichant
le message <code>Bye!</code>.
Ensuite, il rend la main au programme de chargement qui attend l’envoi
d’un nouveau programme&nbsp;:</p>
<pre><code class="icon-keyboard">\\// Starting user program...
Echo&gt; Je viens de taper ceci
Bye!
\\// This is the Virgule program loader.
\\// Send an hex file to execute or press ESC to switch into interactive mode.
</code></pre>
</section>
    
        
    

    

        <footer>
            
    <nav>
    
        <a href="virgule-simple-io-activite.html">&larr;&nbsp;Activité : mon premier système embarqué</a>
    
    
        <a href="virgule-interruptions-activite.html">Activité : gestion d'interruptions&nbsp;&rarr;</a>
    
</nav>

    

            <p class="legal">
                Ce site fait partie des supports pédagogiques conçus et utilisés
                par l'<a href="https://eseo.fr/">ESEO</a> pour ses propres
                offres de formation.
                À l'exception des visuels sous licence libre, la reproduction du
                contenu de ce site sans l'autorisation de l'ESEO est interdite.<br>

                Sauf mention contraire, le texte, les images et les vidéos
                présentés sur ce site ont été créés par Guillaume Savaton.
            </p>
        </footer>
        

<div class="sidebar-show"><i class="fas fa-bars"></i></div>
<div class="sidebar">
    <div class="sidebar-top">
        <div class="sidebar-hide"><i class="fas fa-times-circle"></i></div>
        <form class="search" action="../search.html" method="get">
            <input name="q" type="search" placeholder="Rechercher">
            <button type="submit"><i class="fas fa-search"></i></button>
        </form>
        <a href="../index.html"><i class="fas fa-home"></i>&nbsp;Accueil</a>
    </div>
    
    
        <ul class="toc">
            
                <li>
                    <a href="../termes.html" >Index des termes et des mots-clés</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/index.html" >Représentation des informations</a>
                    
    
        <ul>
            
                <li>
                    <a href="../numerique/analogique-vs-numerique.html" >Analogique vs numérique</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/numeration-binaire.html" >Numération binaire</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/numeration-hexadecimale.html" >Numération hexadécimale</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/arithmetique-binaire.html" >Arithmétique binaire</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/complement-a-deux.html" >Représentation des nombres négatifs</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/index.html" >Circuits logiques</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/combinatoire.html" >Circuits logiques combinatoires</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/combinatoire-fonctions-logiques.html" >Fonctions logiques</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/combinatoire-premiers-circuits-logiques.html" >Nos premiers circuits logiques</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/combinatoire-synthese-logique.html" >Synthèse des fonctions logiques</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/combinatoire-decodeurs-mux-demux.html" >Circuits logiques composés</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel.html" >Circuits logiques séquentiels</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-vs-combinatoire.html" >Combinatoire vs séquentiel</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-element-de-memorisation.html" >Construisons un élément de mémorisation</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-registres-et-compteurs.html" >Registres et compteurs</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-conception-synchrone.html" >Conception de circuits synchrones</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-activite.html" >Activité : circuits logiques séquentiels</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/automates.html" >Automates finis</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/automates-modelisation.html" >Modélisation par graphe d'états</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/automates-mathematiques.html" >Définition mathématique des automates finis</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/automates-synthese.html" >Synthèse des automates finis</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/automates-activite.html" >Activité : automates</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/circuits-programmables.html" >Circuits logiques programmables</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/circuits-programmables-notion.html" >Notion de circuit logique programmable</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/circuits-programmables-simples.html" >Circuits programmables simples (SPLD) et complexes (CPLD)</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/circuits-programmables-fpga.html" >FPGA</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/index.html" >Découverte du langage VHDL</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/hdl.html" >Qu'est-ce qu'un langage de description de matériel ?</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure.html" >Décrire et interconnecter des composants</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/structure-entites.html" >Entités</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure-architectures.html" >Architectures</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure-entites-architectures-activite.html" >Activité : entités et architectures</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure-instanciation.html" >Instanciation d'une entité</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure-instanciation-activite.html" >Activité : instanciation d'une entité</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/combinatoire.html" >Décrire des circuits combinatoires</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/combinatoire-affectations-concurrentes.html" >Affectations concurrentes de signaux</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/combinatoire-affectations-concurrentes-activite.html" >Activité : affectations concurrentes de signaux</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/combinatoire-processus.html" >Processus</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/combinatoire-processus-activite.html" >Activité : processus</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/sequentiel.html" >Décrire des circuits séquentiels</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/sequentiel-bascules-et-registres.html" >Bascules et registres</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/sequentiel-compteurs-et-diviseurs-de-frequence.html" >Compteurs et diviseurs de fréquence</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/sequentiel-automates.html" >Automates</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/sequentiel-activite.html" >Activité : circuits séquentiels</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercices.html" >Exercices</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/exercice-bargraph.html" >Exercice : bargraph</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-blinker.html" >Exercice : faire clignoter une LED</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-dimmer.html" >Exercice : variateur d'intensité lumineuse</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-timepressed.html" >Exercice : mesure de temps d'appui</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-light-sequencer.html" >Exercice : séquenceur lumineux</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-chaser.html" >Exercice : attrape-moi</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-metronome.html" >Exercice : métronome</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-pingpong.html" >Exercice : ping-pong</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="index.html" >Pratique du VHDL : je développe mon propre ordinateur</a>
                    
    
        <ul>
            
                <li>
                    <a href="virgule-simple-io-activite.html" >Activité : mon premier système embarqué</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-uart-activite.html" class="current">Activité : ajout d'une interface série</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-interruptions-activite.html" >Activité : gestion d'interruptions</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-spi-activite.html" >Activité : intégration d'un contrôleur de bus SPI</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-i2c-activite.html" >Activité : intégration d'un contrôleur de bus I<sup>2</sup>C</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-sonar-activite.html" >Activité : intégration d'un récepteur série pour sonar</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-logiciel-activite.html" >Activité : développement logiciel embarqué</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/index.html" >L'essentiel de VHDL</a>
                    
    
        <ul>
            
                <li>
                    <a href="../essentiel-vhdl/unites-de-conception.html" >Unités de conception</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/instructions-concurrentes.html" >Instructions concurrentes</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/instructions-sequentielles.html" >Instructions séquentielles</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/types.html" >Types prédéfinis</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/declarations.html" >Déclarations</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/expressions.html" >Expressions</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/simulation.html" >VHDL pour la simulation</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/index.html" >VHDL avancé : traitement de signaux audio sur FPGA</a>
                    
    
        <ul>
            
                <li>
                    <a href="../vhdl-audio/application.html" >Présentation de l'application</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/preparation.html" >Préparation de l'environnement de travail</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/i2s.html" >Sortie audio I<sup>2</sup>S</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/producteur-consommateur.html" >Connecter producteurs et consommateurs : le protocole ready/valid</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/virgule-fixe.html" >Arithmétique en virgule fixe</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/vocoder-pkg.html" >Le paquetage Vocoder_pkg</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/oscillateur.html" >Oscillateur</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/filtre.html" >Filtre</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/modulateur-melangeur.html" >Modulateur et mélangeur</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/vocodeur.html" >Vocodeur</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/microphone.html" >Entrée audio</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-verilog/index.html" >Découverte du langage Verilog</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-verilog/structure.html" >Décrire et interconnecter des composants</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-verilog/declarations.html" >Déclarations et types de données</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-verilog/combinatoire.html" >Décrire des circuits combinatoires</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-verilog/sequentiel.html" >Décrire des circuits séquentiels</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../verilog-squash/index.html" >Pratique du Verilog : développement d'un jeu vidéo</a>
                    
    
        <ul>
            
                <li>
                    <a href="../verilog-squash/specifications.html" >Présentation de l'application</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/preparation.html" >Préparation de l'environnement de travail</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/structure-generale.html" >Structure générale</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/afficher.html" >Gestion de l'affichage</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/animer.html" >Animer la balle et la raquette</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/deroulement.html" >Gérer le déroulement du jeu</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../soc/index.html" >Introduction au développement d'un System-on-Chip sur circuit programmable</a>
                    
    
        <ul>
            
                <li>
                    <a href="../soc/soc-tutorial.html" >Prise en main de l'environnement de développement</a>
                    
    
        <ul>
            
                <li>
                    <a href="../soc/soc-tutorial-hw.html" >Configuration de la plate-forme matérielle</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-tutorial-os.html" >Configuration du système d'exploitation</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-tutorial-sw.html" >Développement logiciel</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet.html" >Projet : développement d'un capteur connecté</a>
                    
    
        <ul>
            
                <li>
                    <a href="../soc/soc-projet-hw.html" >Création d'un nouveau composant IP</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet-spi.html" >Développement d'un contrôleur de bus SPI</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet-sw.html" >Développement d'un pilote de contrôleur SPI</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet-web.html" >Mise en place d'un serveur web</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet-pmod-acl.html" >Accéléromètre sur bus SPI</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../soc/soc-installation.html" >Installation et configuration des outils de développement</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../annexes/index.html" >Annexes</a>
                    
    
        <ul>
            
                <li>
                    <a href="../annexes/virgule.html" >Virgule : un cœur RISC-V minimal</a>
                    
    

                </li>
            
                <li>
                    <a href="../annexes/installation-xilinx-vivado.html" >Installer Xilinx Vivado</a>
                    
    

                </li>
            
                <li>
                    <a href="../annexes/installation-ghdl-cocotb.html" >Travailler avec des logiciels libres</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
        </ul>
    

</div>
<script type="text/javascript">
    document.querySelector(".sidebar-show").addEventListener("click", () => {
        const sidebar    = document.querySelector(".sidebar");
        const sidebarTop = sidebar.querySelector(".sidebar-top");
        const sidebarToc = sidebar.querySelector(".toc");
        const current    = sidebar.querySelector(".current");
        sidebar.classList.add("sidebar-visible");
        sidebarToc.style.paddingTop = getComputedStyle(sidebarTop).height;
        if (current) {
            current.scrollIntoView({block: "center"});
        }
    });

    document.querySelector(".sidebar-hide").addEventListener("click", () => {
        document.querySelector(".sidebar").classList.remove("sidebar-visible");
    });
</script>

    </body>
</html>
