

<!doctype html>
<html lang="fr">
    <head>
        <title>Activité : gestion d'interruptions</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../assets/normalize.css/normalize.css">
        <link rel="stylesheet" href="../assets/fontawesome/css/all.min.css">
        <link rel="stylesheet" href="../assets/katex/katex.min.css">
        <link rel="stylesheet" href="../styles/page.css">
    </head>
    <body>
        <header>
            
    <nav>
    
        <a href="virgule-uart-activite.html">&larr;&nbsp;Activité : ajout d'une interface série</a>
    
    
        <a href="virgule-spi-activite.html">Activité : intégration d'un contrôleur de bus SPI&nbsp;&rarr;</a>
    
</nav>

    
                <h1>Activité : gestion d'interruptions</h1>
                
                
            

        </header>
        
    
        <ul class="toc">
            
            
                
                <li><a href="#completer-le-projet-vivado">Compléter le projet Vivado</a></li>
            
                
                <li><a href="#lentite-timer">L’entité Timer</a></li>
            
                
                <li><a href="#completer-larchitecture">Compléter l’architecture</a></li>
            
                
                <li><a href="#generer-le-bitstream-et-configurer-le-fpga">Générer le bitstream et configurer le FPGA</a></li>
            
                
                <li><a href="#executer-un-programme-de-demonstration">Exécuter un programme de démonstration</a></li>
            
            
        </ul>
            
    
    <p>Nous allons à présent compléter notre système embarqué en ajoutant un
périphérique qui effectuera des demandes d’interruption périodiques.</p>
<section><h1 id="completer-le-projet-vivado" tabindex="-1">Compléter le projet Vivado</h1>
<p>Si ce n’est pas déjà fait, démarrez Vivado et ouvrez votre projet <code>Computer</code>.</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum
./scripts/vivado
</code></pre>
<p>Ajoutez le fichier <code>CoCiNum/src/vhdl/Timer/Timer.vhd</code> à votre projet.</p>
</section><section><h1 id="lentite-timer" tabindex="-1">L’entité Timer</h1>
<p>Un timer est un périphérique capable de compter le temps et de déclencher
des interruptions périodiques.
L’entité <code>Timer</code> est conçue comme un périphérique pour le processeur <code>Virgule</code> avec les ports suivants&nbsp;:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Port</th>
<th style="text-align:left">Direction</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>clk_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Le signal d’horloge global</td>
</tr>
<tr>
<td style="text-align:left"><code>reset_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">La commande de réinitialisation</td>
</tr>
<tr>
<td style="text-align:left"><code>address_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Le bus d’adresses</td>
</tr>
<tr>
<td style="text-align:left"><code>write_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">La commande d’écriture</td>
</tr>
<tr>
<td style="text-align:left"><code>data_i</code></td>
<td style="text-align:left">Entrée</td>
<td style="text-align:left">Vecteur de 32 bits</td>
<td style="text-align:left">Le bus de données en écriture</td>
</tr>
<tr>
<td style="text-align:left"><code>data_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Vecteur de 32 bits</td>
<td style="text-align:left">Le bus de données en lecture</td>
</tr>
<tr>
<td style="text-align:left"><code>irq_o</code></td>
<td style="text-align:left">Sortie</td>
<td style="text-align:left">Logique</td>
<td style="text-align:left">Demande d’interruption (interrupt request)</td>
</tr>
</tbody>
</table>
<p>L’entrée <code>address_i</code>, sur un bit, permet d’accéder à deux registres de 32 bits&nbsp;:</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>address_i</code></th>
<th style="text-align:left">Registre</th>
<th style="text-align:left">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>'0'</code></td>
<td style="text-align:left"><code>limit_reg</code></td>
<td style="text-align:left">La valeur maximale du compteur.</td>
</tr>
<tr>
<td style="text-align:center"><code>'1'</code></td>
<td style="text-align:left"><code>count_reg</code></td>
<td style="text-align:left">La valeur courante du compteur.</td>
</tr>
</tbody>
</table>
<p>Le fonctionnement du timer est le suivant&nbsp;:</p>
<ul>
<li>Au démarrage, ou lorsque <code>reset_i</code> vaut <code>'1'</code>, les registres <code>limit_reg</code> et <code>count_reg</code> sont mis à zéro.</li>
<li>Lors d’une écriture (<code>write_i = '1'</code>), la valeur de <code>data_i</code> est copiée dans&nbsp;:
<ul>
<li><code>limit_reg</code> si <code>address_i = '0'</code>,</li>
<li><code>count_reg</code> si <code>address_i = '1'</code>.</li>
</ul>
</li>
<li>Dans les autres cas,
<ul>
<li>si <code>count_reg</code> ≥ <code>limit_reg</code>, alors <code>count_reg</code> revient à zéro,</li>
<li>si <code>count_reg</code> &lt; <code>limit_reg</code>, alors <code>count_reg</code> s’incrémente.</li>
</ul>
</li>
</ul>
<p>La sortie <code>data_o</code> est égale à&nbsp;:</p>
<ul>
<li><code>limit_reg</code> lorsque <code>address_i = '0'</code></li>
<li><code>count_reg</code> lorsque <code>address_i = '1'</code></li>
</ul>
<p>Si <code>limit_reg</code> est non nul, la sortie <code>irq_o</code> vaut <code>'1'</code> à la fin de chaque
cycle de comptage, c’est-à-dire lorsque <code>count_reg</code> ≥ <code>limit_reg</code>.</p>
<p>Si <code>limit_reg</code> vaut zéro, le timer ne compte pas et ne produit aucune
demande d’interruption.</p>
</section><section><h1 id="completer-larchitecture" tabindex="-1">Compléter l’architecture</h1>
<p>Dans le fichier <code>Computer_pkg.vhd</code>, ajoutez les définitions suivantes pour
définir la plage d’adresses associée au timer&nbsp;:</p>
<pre><code class="language-vhdl"><span class="hljs-keyword">constant</span> TIMER_ADDRESS : <span class="hljs-built_in">unsigned</span> := x<span class="hljs-string">"83000000"</span>;
<span class="hljs-keyword">constant</span> TIMER_SIZE    : <span class="hljs-built_in">positive</span> := <span class="hljs-number">8</span>;

<span class="hljs-keyword">constant</span> INTC_EVENTS_TIMER : <span class="hljs-built_in">natural</span> := <span class="hljs-number">2</span>;

<span class="hljs-comment">-- Complétez le type device_t existant</span>
<span class="hljs-keyword">type</span> device_t <span class="hljs-keyword">is</span> (..., TIMER);
</code></pre>
<p>Modifiez le fichier <code>Computer.vhd</code> pour intégrer le timer dans notre système&nbsp;:</p>
<p><a href="Computer-Timer-architecture.svg"><img src="Computer-Timer-architecture.svg" alt="L'architecture pour l'entité Computer avec Timer"></a></p>
<div class="caption">
<p><a href="../langage-vhdl/legende.svg" target="_blank"><i class="fas fa-info-circle"></i> Afficher la légende des schémas.</a></p>
</div>
</section><section><h1 id="generer-le-bitstream-et-configurer-le-fpga" tabindex="-1">Générer le bitstream et configurer le FPGA</h1>
<p>Générez le fichier binaire à charger dans le FPGA&nbsp;:
<em>Flow Navigator</em> → <em>Program and Debug</em> → <em>Generate Bitstream</em>.</p>
<p>Si ce n’est pas déjà fait, reliez le connecteur micro-USB de la carte à un port USB de votre PC et
mettez la carte sous tension.
Ouvrez ensuite un terminal pour port série&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum
./scripts/gtkterm
</code></pre>
<p>Dans le menu <em>Configuration</em> de GTKTerm, activez l’option <em>CR LF auto</em>.</p>
<p>Connectez Vivado à votre carte Basys3&nbsp;: <em>Flow Navigator</em> → <em>Program and Debug</em> → <em>Open Hardware Manager</em> → <em>Open Target</em> → <em>Auto-connect</em>.</p>
<p>Configurez le FPGA&nbsp;: <em>Flow Navigator</em> → <em>Program and Debug</em> → <em>Open Hardware Manager</em> → <em>Program Device</em>.</p>
<p>Comme lors de l’étape précédente, la fenêtre GTKTerm doit à présent afficher le texte&nbsp;:</p>
<pre><code>\\// This is the Virgule program loader. Please send an hex file to execute...
</code></pre>
</section><section><h1 id="executer-un-programme-de-demonstration" tabindex="-1">Exécuter un programme de démonstration</h1>
<p>Nous allons créer un nouveau programme en langage C.
Dans un terminal, exécutez les commandes suivantes&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum/src/c
mkdir Tick
<span class="hljs-built_in">cd</span> Tick
gedit Tick.c &amp;
</code></pre>
<p>Ce programme configure le timer pour demander des interruptions toutes
les secondes.
À chaque demande d’interruption, la fonction <code>irq_handler</code> est
appelée automatiquement et affiche la chaîne <code>"Tick!"</code> dans le terminal.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span>

<span class="hljs-comment">// Définition des adresses des périphériques.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_ADDR  0x81000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_ADDR  0x82000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMER_ADDR 0x83000000</span>

<span class="hljs-comment">// Définition des registres des périphériques.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_MASK_REG   INTC_ADDR</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_EVENTS_REG (INTC_ADDR + 4)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_DATA_REG   UART_ADDR</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMER_LIMIT_REG TIMER_ADDR</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMER_COUNT_REG (TIMER_ADDR + 4)</span>

<span class="hljs-comment">// Définition des masques pour détecter et acquitter les événements.</span>
<span class="hljs-comment">// masque = 2^(numéro de l'événement)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_EVENTS_UART_RX 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_EVENTS_UART_TX 2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTC_EVENTS_TIMER   4</span>

<span class="hljs-comment">// La fréquence d'horloge permettra de configurer le timer.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CLK_FREQUENCY_HZ 100e6</span>

<span class="hljs-comment">/* -------------------------------------------------------------------------- *
 * Fonctions d'accès aux registres des périphériques.
 * -------------------------------------------------------------------------- */</span>

<span class="hljs-comment">// Lire un octet à l'adresse addr.</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">read8</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span> {
    <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>*)addr;
}

<span class="hljs-comment">// Écrire l'octet val à l'adresse addr.</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">write8</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span> val)</span> {
    *(<span class="hljs-type">uint8_t</span>*)addr = val;
}

<span class="hljs-comment">// Lire un mot de 32 bits à l'adresse addr.</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">read32</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span> {
    <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>*)addr;
}

<span class="hljs-comment">// Écrire le mot de 32 bits val à l'adresse addr.</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">write32</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint32_t</span> val)</span> {
    *(<span class="hljs-type">uint32_t</span>*)addr = val;
}

<span class="hljs-comment">/* -------------------------------------------------------------------------- *
 * Fonctions de lecture/écriture sur l'interface série.
 * -------------------------------------------------------------------------- */</span>

<span class="hljs-comment">// Envoyer un caractère à travers la liaison série.</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">UART_send_char</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> {
    <span class="hljs-comment">// Ecrire le caractère dans le registre de données.</span>
    write8(UART_DATA_REG, c);
    <span class="hljs-comment">// Attendre que l'envoi soit terminé.</span>
    <span class="hljs-keyword">while</span> (!(read32(INTC_EVENTS_REG) &amp; INTC_EVENTS_UART_TX));
    <span class="hljs-comment">// Signaler que l'événement a été traité.</span>
    write32(INTC_EVENTS_REG, INTC_EVENTS_UART_TX);
}

<span class="hljs-comment">// Envoyer une chaîne de caractères à travers la liaison série.</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">UART_send_string</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *str)</span> {
    <span class="hljs-comment">// Tant que le caractère courant est non nul.</span>
    <span class="hljs-keyword">while</span> (*str) {
        <span class="hljs-comment">// Envoyer le caractère courant.</span>
        UART_send_char(*str);
        <span class="hljs-comment">// Passer au caractère suivant.</span>
        str ++;
    }
}

<span class="hljs-comment">/* -------------------------------------------------------------------------- *
 * Programme principal.
 * -------------------------------------------------------------------------- */</span>

<span class="hljs-comment">// Cette fonction sera exécutée à chaque demande d'interruption.</span>
__attribute__((interrupt(<span class="hljs-string">"machine"</span>)))
<span class="hljs-type">void</span> <span class="hljs-title function_">irq_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-comment">// Vérifier qu'il s'agit bien d'une interruption du timer.</span>
    <span class="hljs-keyword">if</span> (read32(INTC_EVENTS_REG) &amp; INTC_EVENTS_TIMER) {
        <span class="hljs-comment">// Signaler que l'événement a été traité.</span>
        write32(INTC_EVENTS_REG, INTC_EVENTS_TIMER);
        <span class="hljs-comment">// Afficher un message.</span>
        UART_send_string(<span class="hljs-string">"Tick! "</span>);
    }
}

<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-comment">// Activer les interruptions du timer.</span>
    write32(INTC_MASK_REG, INTC_EVENTS_TIMER);
    <span class="hljs-comment">// Régler le cycle de comptage sur 1 seconde.</span>
    write32(TIMER_LIMIT_REG, CLK_FREQUENCY_HZ - <span class="hljs-number">1</span>);
    <span class="hljs-comment">// Attendre la réception d'un caractère par la liaison série.</span>
    <span class="hljs-comment">// Pendant ce temps, le timer demande des interruptions toutes les secondes.</span>
    UART_send_string(<span class="hljs-string">"Press a key to terminate the program.\n"</span>);
    <span class="hljs-keyword">while</span> (!(read32(INTC_EVENTS_REG) &amp; INTC_EVENTS_UART_RX));
    UART_send_string(<span class="hljs-string">"\nBye!\n"</span>);
}
</code></pre>
<p>Compilez ce programme&nbsp;:</p>
<pre><code class="icon-term language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/CoCiNum/src/c/Tick
riscv64-unknown-elf-gcc -march=rv32i -mabi=ilp32 -ffreestanding -nostdlib -T ../../../scripts/Virgule.ld -o Tick.elf ../../asm/Startup/Startup.s Tick.c
riscv64-unknown-elf-objcopy -O ihex Tick.elf Tick.hex
</code></pre>
<p>En cas de problème à l’exécution du compilateur C, vous pouvez créer vous-même
le fichier <code>Tick.hex</code> avec le contenu suivant&nbsp;:</p>
<pre><code>:100000006F0040016F00C00A4800000000000000BF
:1000100073002030970100009381C11C170101007B
:10002000130141FE9302001E1303001E63F86200D9
:1000300023A0020093824200E3EC62FEEF00001274
:100040009702000083A282FC67800200000000008B
:100050000000000000000000B70700822380A70016
:10006000370700818327470093F72700E38C07FEBB
:10007000930720002322F70067800000130101FF8F
:1000800023248100232611001304050003450400E6
:10009000631A05008320C1000324810013010101BC
:1000A00067800000EFF05FFB130414006FF01FFE89
:1000B000130101FC232EE10037070081232CF100FE
:1000C00083274700232E1102232C5102232A610289
:1000D000232871022326A1022324B1022322C10274
:1000E0002320D102232A0101232811012326C10143
:1000F0002324D1012322E1012320F10193F74700BA
:10010000638A0700930740002322F7001305801A33
:10011000EFF0DFF68320C103832281030323410331
:10012000832301030325C1028325810203264102A3
:10013000832601020327C10183278101032841018E
:1001400083280101032EC100832E8100032F41006B
:10015000832F01001301010473002030130101FFFC
:1001600023261100B70700811307400023A0E700F2
:10017000B7E7F505370700839387F70F2320F700CC
:100180001305001BEFF09FEF37070081832747001F
:1001900093F71700E38C07FE8320C1001305801D31
:0801A000130101016FF09FED56
:1001A8005469636B212000005072657373206120CD
:1001B8006B657920746F207465726D696E61746502
:1001C800207468652070726F6772616D2E0A000076
:0701D8000A427965210A00CB
:00000001FF
</code></pre>
<p>Dans la fenêtre terminal de Linux qui vous a servi à lancer GTKTerm,
exécutez la commande&nbsp;:</p>
<pre><code class="icon-term language-bash">cat <span class="hljs-variable">$HOME</span>/CoCiNum/src/c/Tick/Tick.hex &gt; /dev/ttyUSB1
</code></pre>
<!-- Dans GTKTerm, dans le menu *File*, choisissez *Send Raw File*
et sélectionnez le fichier `CoCiNum/src/c/Tick/Tick.hex`. -->
<p>Observez le résultat de l’exécution du programme.
Dans GTKTerm, pressez une touche pour terminer.</p>
</section>
    
        
    

    
    <footer>
        <nav>
    
        <a href="virgule-uart-activite.html">&larr;&nbsp;Activité : ajout d'une interface série</a>
    
    
        <a href="virgule-spi-activite.html">Activité : intégration d'un contrôleur de bus SPI&nbsp;&rarr;</a>
    
</nav>

    </footer>

        <div class="sidebar-show"><i class="fas fa-bars"></i></div>
        <div class="sidebar">
            <div class="sidebar-top">
                <div class="sidebar-hide"><i class="fas fa-times-circle"></i></div>
                <form class="search" action="../search.html" method="get">
                    <input name="q" type="search" placeholder="Rechercher">
                    <button type="submit"><i class="fas fa-search"></i></button>
                </form>
                <a href="../index.html"><i class="fas fa-home"></i>&nbsp;Accueil</a>
            </div>
            
    
        <ul class="toc">
            
                <li>
                    <a href="../termes.html" >Index des termes et des mots-clés du langage VHDL</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/index.html" >Représentation des informations</a>
                    
    
        <ul>
            
                <li>
                    <a href="../numerique/analogique-vs-numerique.html" >Analogique vs numérique</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/numeration-binaire.html" >Numération binaire</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/numeration-hexadecimale.html" >Numération hexadécimale</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/arithmetique-binaire.html" >Arithmétique binaire</a>
                    
    

                </li>
            
                <li>
                    <a href="../numerique/complement-a-deux.html" >Représentation des nombres négatifs</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/index.html" >Circuits logiques</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/combinatoire.html" >Circuits logiques combinatoires</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/combinatoire-fonctions-logiques.html" >Fonctions logiques</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/combinatoire-premiers-circuits-logiques.html" >Nos premiers circuits logiques</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/combinatoire-synthese-logique.html" >Synthèse des fonctions logiques</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/combinatoire-decodeurs-mux-demux.html" >Circuits logiques composés</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel.html" >Circuits logiques séquentiels</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-vs-combinatoire.html" >Combinatoire vs séquentiel</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-element-de-memorisation.html" >Construisons un élément de mémorisation</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-registres-et-compteurs.html" >Registres et compteurs</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-conception-synchrone.html" >Conception de circuits synchrones</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/sequentiel-activite.html" >Activité : circuits logiques séquentiels</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/automates.html" >Automates finis</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/automates-modelisation.html" >Modélisation par graphe d'états</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/automates-mathematiques.html" >Définition mathématique des automates finis</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/automates-synthese.html" >Synthèse des automates finis</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/automates-activite.html" >Activité : automates</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/circuits-programmables.html" >Circuits logiques programmables</a>
                    
    
        <ul>
            
                <li>
                    <a href="../circuits-logiques/circuits-programmables-notion.html" >Notion de circuit logique programmable</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/circuits-programmables-simples.html" >Circuits programmables simples (SPLD) et complexes (CPLD)</a>
                    
    

                </li>
            
                <li>
                    <a href="../circuits-logiques/circuits-programmables-fpga.html" >FPGA</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/index.html" >Découverte du langage VHDL</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/hdl.html" >Qu'est-ce qu'un langage de description de matériel ?</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure.html" >Décrire et interconnecter des composants</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/structure-entites.html" >Entités</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure-architectures.html" >Architectures</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure-entites-architectures-activite.html" >Activité : entités et architectures</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure-instanciation.html" >Instanciation d'une entité</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/structure-instanciation-activite.html" >Activité : instanciation d'une entité</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/combinatoire.html" >Décrire des circuits combinatoires</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/combinatoire-affectations-concurrentes.html" >Affectations concurrentes de signaux</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/combinatoire-affectations-concurrentes-activite.html" >Activité : affectations concurrentes de signaux</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/combinatoire-processus.html" >Processus</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/combinatoire-processus-activite.html" >Activité : processus</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/sequentiel.html" >Décrire des circuits séquentiels</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/sequentiel-bascules-et-registres.html" >Bascules et registres</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/sequentiel-compteurs-et-diviseurs-de-frequence.html" >Compteurs et diviseurs de fréquence</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/sequentiel-automates.html" >Automates</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/sequentiel-activite.html" >Activité : circuits séquentiels</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercices.html" >Exercices</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-vhdl/exercice-bargraph.html" >Exercice : bargraph</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-blinker.html" >Exercice : faire clignoter une LED</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-dimmer.html" >Exercice : variateur d'intensité lumineuse</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-timepressed.html" >Exercice : mesure de temps d'appui</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-light-sequencer.html" >Exercice : séquenceur lumineux</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-chaser.html" >Exercice : attrape-moi</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-metronome.html" >Exercice : métronome</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-vhdl/exercice-pingpong.html" >Exercice : ping-pong</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="index.html" >Pratique du VHDL : je développe mon propre ordinateur</a>
                    
    
        <ul>
            
                <li>
                    <a href="virgule-simple-io-activite.html" >Activité : mon premier système embarqué</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-uart-activite.html" >Activité : ajout d'une interface série</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-interruptions-activite.html" class="current">Activité : gestion d'interruptions</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-spi-activite.html" >Activité : intégration d'un contrôleur de bus SPI</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-i2c-activite.html" >Activité : intégration d'un contrôleur de bus I<sup>2</sup>C</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-sonar-activite.html" >Activité : intégration d'un récepteur série pour sonar</a>
                    
    

                </li>
            
                <li>
                    <a href="virgule-logiciel-activite.html" >Activité : développement logiciel embarqué</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/index.html" >L'essentiel de VHDL</a>
                    
    
        <ul>
            
                <li>
                    <a href="../essentiel-vhdl/unites-de-conception.html" >Unités de conception</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/instructions-concurrentes.html" >Instructions concurrentes</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/instructions-sequentielles.html" >Instructions séquentielles</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/types.html" >Types prédéfinis</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/declarations.html" >Déclarations</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/expressions.html" >Expressions</a>
                    
    

                </li>
            
                <li>
                    <a href="../essentiel-vhdl/simulation.html" >VHDL pour la simulation</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/index.html" >VHDL avancé : traitement de signaux audio sur FPGA</a>
                    
    
        <ul>
            
                <li>
                    <a href="../vhdl-audio/application.html" >Présentation de l'application</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/preparation.html" >Préparation de l'environnement de travail</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/i2s.html" >Sortie audio I<sup>2</sup>S</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/producteur-consommateur.html" >Connecter producteurs et consommateurs : le protocole ready/valid</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/virgule-fixe.html" >Arithmétique en virgule fixe</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/vocoder-pkg.html" >Le paquetage Vocoder_pkg</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/oscillateur.html" >Oscillateur</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/filtre.html" >Filtre</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/modulateur-melangeur.html" >Modulateur et mélangeur</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/vocodeur.html" >Vocodeur</a>
                    
    

                </li>
            
                <li>
                    <a href="../vhdl-audio/microphone.html" >Entrée audio</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../langage-verilog/index.html" >Découverte du langage Verilog</a>
                    
    
        <ul>
            
                <li>
                    <a href="../langage-verilog/structure.html" >Décrire et interconnecter des composants</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-verilog/declarations.html" >Déclarations et types de données</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-verilog/combinatoire.html" >Décrire des circuits combinatoires</a>
                    
    

                </li>
            
                <li>
                    <a href="../langage-verilog/sequentiel.html" >Décrire des circuits séquentiels</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../verilog-squash/index.html" >Pratique du Verilog : développement d'un jeu vidéo</a>
                    
    
        <ul>
            
                <li>
                    <a href="../verilog-squash/specifications.html" >Présentation de l'application</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/preparation.html" >Préparation de l'environnement de travail</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/structure-generale.html" >Structure générale</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/afficher.html" >Gestion de l'affichage</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/animer.html" >Animer la balle et la raquette</a>
                    
    

                </li>
            
                <li>
                    <a href="../verilog-squash/deroulement.html" >Gérer le déroulement du jeu</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../soc/index.html" >Introduction au développement d'un System-on-Chip sur circuit programmable</a>
                    
    
        <ul>
            
                <li>
                    <a href="../soc/soc-tutorial.html" >Prise en main de l'environnement de développement</a>
                    
    
        <ul>
            
                <li>
                    <a href="../soc/soc-tutorial-hw.html" >Configuration de la plate-forme matérielle</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-tutorial-os.html" >Configuration du système d'exploitation</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-tutorial-sw.html" >Développement logiciel</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet.html" >Projet : développement d'un capteur connecté</a>
                    
    
        <ul>
            
                <li>
                    <a href="../soc/soc-projet-hw.html" >Création d'un nouveau composant IP</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet-spi.html" >Développement d'un contrôleur de bus SPI</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet-sw.html" >Développement d'un pilote de contrôleur SPI</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet-web.html" >Mise en place d'un serveur web</a>
                    
    

                </li>
            
                <li>
                    <a href="../soc/soc-projet-pmod-acl.html" >Accéléromètre sur bus SPI</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../soc/soc-installation.html" >Installation et configuration des outils de développement</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
                <li>
                    <a href="../annexes/index.html" >Annexes</a>
                    
    
        <ul>
            
                <li>
                    <a href="../annexes/virgule.html" >Virgule : un cœur RISC-V minimal</a>
                    
    

                </li>
            
                <li>
                    <a href="../annexes/installation-xilinx-vivado.html" >Installer Xilinx Vivado</a>
                    
    

                </li>
            
                <li>
                    <a href="../annexes/installation-ghdl-cocotb.html" >Travailler avec des logiciels libres</a>
                    
    

                </li>
            
        </ul>
    

                </li>
            
        </ul>
    

        </div>
        <script type="text/javascript">
            document.querySelector(".sidebar-show").addEventListener("click", () => {
                const sidebar    = document.querySelector(".sidebar");
                const sidebarTop = sidebar.querySelector(".sidebar-top");
                const sidebarToc = sidebar.querySelector(".toc");
                const current    = sidebar.querySelector(".current");
                sidebar.classList.add("sidebar-visible");
                sidebarToc.style.paddingTop = getComputedStyle(sidebarTop).height;
                if (current) {
                    current.scrollIntoView({block: "center"});
                }
            });

            document.querySelector(".sidebar-hide").addEventListener("click", () => {
                document.querySelector(".sidebar").classList.remove("sidebar-visible");
            });
        </script>
    </body>
</html>
